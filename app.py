# app.py
import bs4
from bs4 import BeautifulSoup
import flask
from flask import Flask, request, jsonify, url_for
import os
import psycopg2
import re
import requests

# local imports
from ml import ml

app = Flask(__name__)

#!########## Internal helper functions ##########
def is_not_hashtag(obj):
    return type(obj) != type(bs4.Tag(name=''))

# Returns list of tuples (tweet, tweet_id) for tweets that are NOT retweets
def get_tweets(handle,  filter_scientific, science_word_threshold = 2, debug=False):
    response = requests.request(method="get", url=f"https://syndication.twitter.com/timeline/profile/?screen_name={handle}&with_replies=1")
    soup = BeautifulSoup(response.json()['body'], "html.parser")

    # all tweets regardless of whether retweet or not
    all_tweets = [tweet.contents[0] for tweet in soup.find_all("p", class_="timeline-Tweet-text")]

    # all this stuff to get tweet ID
    all_ids = [re.search('/status/(\d+)', a_tag['href']).group(1) for a_tag in soup.find_all("a", class_ = "timeline-Tweet-timestamp")]

    # filter out hashtags 
    all_tweets = list(filter(lambda obj: type(obj[1]) != type(bs4.Tag(name='')), enumerate(all_tweets)))
    indices_to_keep, all_tweets = map(list, list(zip(*all_tweets)))

    if debug:
        print("ALL Tweets: [")
        for _id, _tweet in zip(all_ids, all_tweets):
            print(f'\tID: {_id}, Text: {_tweet},')
        print("]")

    # filter out retweets
    for idx, author in enumerate(soup.find_all("span", class_ = "TweetAuthor-screenName Identity-screenName")):
        if author.contents[0].lower() != f"@{handle}".lower() and idx in indices_to_keep: # if have to remove it
            indices_to_keep.remove(idx)
    
    user_tweets = [tweet for i, tweet in enumerate(all_tweets) if i in indices_to_keep]
    user_ids = [_id for idx, _id in enumerate(all_ids) if idx in indices_to_keep]

    if filter_scientific:
        for idx, tweet in enumerate(user_tweets):
            c, text = ml.get_science_word_count(tweet)
            text = text.split()
            print(f"For tweet ({tweet.strip()}), no of science words: {c}")
            # ratio of scientific words in the tweet to total no of words in the tweet should be greater than 1
            # if len(text) == 0 or (c/len(text) < science_word_threshold): 
            if c < science_word_threshold and not (len(text) <= 3 and c == 1) and idx in indices_to_keep:
                indices_to_keep.remove(idx)

        user_tweets = [tweet for i, tweet in enumerate(all_tweets) if i in indices_to_keep]
        user_ids = [_id for idx, _id in enumerate(all_ids) if idx in indices_to_keep]

    if debug:
        print(f"User tweets: {user_tweets}")
        print(f"User ids: {user_ids}")

    return list(zip(user_tweets, user_ids))

#!########## DATABASE STUFF ##########
def init_db():
    conn = psycopg2.connect(dsn=os.getenv('DATABASE_URL')) #"postgresql://postgres:root@localhost/axis_hack_db"
    cur = conn.cursor()
    
    # cur.execute('DROP TABLE IF EXISTS bot_history')
    cur.execute(
    'CREATE TABLE IF NOT EXISTS bot_history ('
        's_no SERIAL PRIMARY KEY,'
        'reply_content varchar(288),'   # content to reply to the tweet with (generated by ML)
        'tweet_id varchar(20),'         # ID of the tweet the user clicked the "reply" button for.
        'user_handle varchar(100)'     # author of the tweet the user wants to reply to.
        ')'
    )
    # cur.execute('INSERT INTO bot_history (reply_content, tweet_id, tweet_author) VALUES (%s, %s, %s)', ("reply to the tweet", "tweet_ID_heeHee", "bruhshikesh"))

    conn.commit()
    # print("Create table if not exists done.")
    
    cur.close()
    return conn

def insert_history(reply_text, tweet_id, user_handle): 
    conn = init_db()
    cur = conn.cursor()
    
    cur.execute("INSERT INTO bot_history (reply_content, tweet_id, user_handle) VALUES (%s, %s, %s)", (reply_text, tweet_id, user_handle))
    conn.commit()

    cur.close()
    conn.close()

##########! ACTUAL FLASK ENDPOINTS ###########

# takes just one tweet ID as GET parameter and inserts into table
@app.route('/update_history/', methods=['POST', 'GET'])
def update_history():
    tweet_id = request.values.get('tweet_id')
    tweet_text = request.values.get('tweet_text')
    user_handle = request.values.get('user_handle')
    
    if tweet_id and tweet_text and user_handle:
        reply_text = ml.tweet_get_reply(tweet_text)[:279]
        print(f"Found tweet text: {tweet_text}")
        print(f"Reply text: {reply_text}")
        insert_history(reply_text, tweet_id, user_handle)

        resp = flask.make_response({ # When a dict is passed to this, it automatically gets json-ified
            "tweet_id": tweet_id,
            "user_handle": user_handle,
            "tweet_text": tweet_text,
            "reply_text": reply_text,
        })
    else:
        resp = flask.make_response({ # When a dict is passed to this, it automatically gets json-ified
            "ERROR": "Enter tweet_id, tweet_text and user_handle fields!"
        })

    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route('/history/', methods=['POST', 'GET'])
def show_history():
    conn = init_db()
    cur = conn.cursor()

    user_handle = request.values.get('user_handle')
    if user_handle is None:
        return flask.make_response({
            "ERROR": "Send user handle in request!"
        })
    
    # do a select query and get history
    cur.execute("SELECT * FROM bot_history",)
    results = cur.fetchall()

    cur.close()
    conn.close()
    
    if results:
        tweets = get_tweets(user_handle, filter_scientific=False)
        tweets = list([i.strip() for i, j in tweets])
        print(f"Tweets of user {user_handle}: {tweets}")
        print(f"Results: {results}")

        _, x, _, _ = (zip(*results))    # list of all reply_contents
        x = list([i.strip() for i in x])
        print(f"x = {x}")
        resp = flask.make_response({
            "Records" : [tweet for tweet in tweets if tweet in x]
        })
    else:
        resp = flask.make_response({
            "Records" : []
        })

    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route('/display/', methods=['POST', 'GET'])
def display():
    handle = request.args.get('handle')
    tweets = get_tweets(handle, filter_scientific=True, debug=True)
    print(f"Handle = {handle}")

    # You can add the test cases you made in the previous function, but in our case here you are just testing the POST functionality
    if handle:
        handle = handle.lower() # since it is NOT case-sensitive
        resp = flask.make_response({
            "Handle": f"{handle}",
            "Tweets": tweets 
        })    
    else:
        resp = flask.make_response({
            "ERROR": "No handle found, please send a handle."
        })

    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

# index.html basically (not needed in production because we have React frontend)
@app.route('/')
def index():
    resp = flask.make_response(
        "<h1>Welcome to the backend webapp!</h1>" + \
        f"<form action=\"{url_for('display')}\"> " + \
        "Enter twitter handle to search: <input type=\"text\" id=\"handle\" name=\"handle\">" + \
        f"</form>"
    )
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

if __name__ == '__main__':
    # Threaded option to enable multiple instances for multiple user access support
    app.run(
        threaded=True, 
        port=5000, 
        debug=True
    )