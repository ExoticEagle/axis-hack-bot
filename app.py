# app.py
# import asyncpg
import bs4
from bs4 import BeautifulSoup
import flask
from flask import Flask, request, jsonify, url_for
import json
import os
import psycopg2
import re
import requests

app = Flask(__name__)

#!########## Internal helper functions ##########
def is_not_hashtag(obj):
    return type(obj) != type(bs4.Tag(name=''))

# Returns list of tuples (tweet, tweet_id) for tweets that are NOT retweets
def get_tweets(handle, debug=False):
    response = requests.request(method="get", url=f"https://syndication.twitter.com/timeline/profile/?screen_name={handle}")
    soup = BeautifulSoup(response.json()['body'], "html.parser")

    # all tweets regardless of whether retweet or not
    all_tweets = [tweet.contents[0] for tweet in soup.find_all("p", class_="timeline-Tweet-text")]

    # all this stuff to get tweet ID
    all_ids = [re.search('/status/(\d+)', a_tag['href']).group(1) for a_tag in soup.find_all("a", class_ = "timeline-Tweet-timestamp")]

    # filter out hashtags 
    all_tweets = list(filter(lambda obj: type(obj[1]) != type(bs4.Tag(name='')), enumerate(all_tweets)))
    indices_to_keep, all_tweets = map(list, list(zip(*all_tweets)))

    if debug:
        print("ALL Tweets: [")
        for _id, _tweet in zip(all_ids, all_tweets):
            print(f'\tID: {_id}, Text: {_tweet},')
        print("]")

    # filter out retweets
    for idx, author in enumerate(soup.find_all("span", class_ = "TweetAuthor-screenName Identity-screenName")):
        if author.contents[0].lower() != f"@{handle}".lower() and idx in indices_to_keep: # if have to remove it
            indices_to_keep.remove(idx)

    user_tweets = [tweet for i, tweet in enumerate(all_tweets) if i in indices_to_keep]
    user_ids = [_id for idx, _id in enumerate(all_ids) if idx in indices_to_keep]

    if debug:
        print(f"User tweets: {user_tweets}")
        print(f"User ids: {user_ids}")

    return list(zip(user_tweets, user_ids))
    
#! ML STUFF
def get_reply_text(tweet_text):
	return "Not implemented yet!"

#!########## DATABASE STUFF ##########
def init_db():
    conn = psycopg2.connect(dsn=os.getenv('DATABASE_URL')) #"postgresql://postgres:root@localhost/axis_hack_db"
    cur = conn.cursor()
    
    # cur.execute('DROP TABLE IF EXISTS bot_history')
    cur.execute(
    'CREATE TABLE IF NOT EXISTS bot_history ('
        's_no SERIAL PRIMARY KEY,'
        'reply_content varchar(288),'   # content to reply to the tweet with (generated by ML)
        'tweet_id varchar(20),'         # ID of the tweet the user clicked the "reply" button for.
        'tweet_author varchar(100)'     # author of the tweet the user wants to reply to.
        ')'
    )
    # cur.execute('INSERT INTO bot_history (reply_content, tweet_id, tweet_author) VALUES (%s, %s, %s)', ("reply to the tweet", "tweet_ID_heeHee", "bruhshikesh"))

    conn.commit()
    # print("Create table if not exists done.")
    
    cur.close()
    return conn

def insert_history(reply_text, tweet_id, tweet_author): 
    conn = init_db()
    cur = conn.cursor()
    
    cur.execute("INSERT INTO bot_history (reply_content, tweet_id, tweet_author) VALUES (%s, %s, %s)", (reply_text, tweet_id, tweet_author))
    conn.commit()

    cur.close()
    conn.close()

##########! ACTUAL FLASK ENDPOINTS ###########

# takes just one tweet ID as GET parameter and inserts into table
@app.route('/update_history/', methods=['POST', 'GET'])
def update_history():
    tweet_id = request.args.get('tweet_id')
    tweet_author = request.args.get('tweet_author')
    
    if tweet_id and tweet_author:
        try:
            tweet_text = list(filter(lambda x:  x[1]==tweet_id, get_tweets(tweet_author)))[0][0]
            reply_text = get_reply_text(tweet_text)
            insert_history(reply_text, tweet_id, tweet_author)
            print(f"Found tweet text: {tweet_text}")
        except:
            print(f"Tweet text not found! (None)")
            tweet_text = None
            reply_text = None    
        finally:
            resp = flask.make_response({ # When a dict is passed to this, it automatically gets json-ified
                "Hello": "oh hi. update_history() function is over.",
                "tweet_id": tweet_id,
                "tweet_author": tweet_author,
                "tweet_text": tweet_text,
                "reply_text": reply_text,
            })
    else:
        resp = flask.make_response({ # When a dict is passed to this, it automatically gets json-ified
            "ERROR": "Enter both 'tweet_id and tweet_author fields!"
        })

    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route('/history/', methods=['POST', 'GET'])
def show_history():
    
    conn = init_db()
    cur = conn.cursor()

    tweet_author = request.values.get('tweet_author')
    if tweet_author is None:
        return flask.make_response({
            "ERROR": "Send tweet_author handle in request!"
        })
    
    # do a select query and get history
    cur.execute("SELECT * FROM bot_history WHERE tweet_author LIKE %s ESCAPE ''", (tweet_author,))
    results = cur.fetchall()

    cur.close()
    conn.close()
    
    print(results)
    resp = flask.make_response({
        "Records" : [list(record)[1:] for record in results]
    })
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

@app.route('/display/', methods=['POST', 'GET'])
def display():
    handle = request.args.get('handle')
    tweets = get_tweets(handle, debug=True)
    print(f"Handle = {handle}")

    # You can add the test cases you made in the previous function, but in our case here you are just testing the POST functionality
    if handle:
        handle = handle.lower() # since it is NOT case-sensitive
        resp = flask.make_response({
            "Handle": f"{handle}",
            "Tweets": tweets 
        })    
    else:
        resp = flask.make_response({
            "ERROR": "No handle found, please send a handle."
        })

    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

# index.html basically (not needed in production because we have React frontend)
@app.route('/')
def index():
    resp = flask.make_response(
        "<h1>Welcome to the backend webapp!</h1>" + \
        f"<form action=\"{url_for('display')}\"> " + \
        "Enter twitter handle to search: <input type=\"text\" id=\"handle\" name=\"handle\">" + \
        f"</form>"
    )
    resp.headers['Access-Control-Allow-Origin'] = '*'
    return resp

if __name__ == '__main__':
    # Threaded option to enable multiple instances for multiple user access support
    app.run(
        threaded=True, 
        port=5000, 
        debug=True
    )